parameters:
  dependsOn: 'Build'
  artifactName: 'Module'
  stagingDirectory: $(Build.ArtifactStagingDirectory)
  modulesToImport: ''
  customRulePath: ''
  excludeRules: '"PSShouldProcess","PSUseShouldProcessForStateChangingFunctions"'
  pool:
    vmImage: 'windows-2019'

jobs:
  - job: ScriptAnalyzer
    dependsOn: ${{ parameters.dependsOn }}
    workspace:
      clean: outputs

    pool: ${{ parameters.pool }}

    steps:
    # we shouldn't need to checkout, but we need the RequiredModules - what can we do?
    - checkout: self
      lfs: true

    - template: InstallRequiredModules-step.yml

    # If we depends on a build step, then we should download the artifact
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Build Artifacts'
      condition: ${{ ne('', parameters.artifactName)}}
      inputs:
        artifactName: ${{ parameters.artifactName }}
        downloadPath: ${{ parameters.artifactDownloadDirectory }}

    - powershell: |
        # Install the latest PSScriptAnalyzer (TODO: support specifying the version)
        $Policy = (Get-PSRepository PSGallery).InstallationPolicy
        Set-PSRepository PSGallery -InstallationPolicy Trusted
        try {
            $PSSA = Find-Module PSScriptAnalyzer
            if (-not (Get-Module PSScriptAnalyzer -ListAvailable | Where-Object Version -ge $PSSA.Version)) {
                Install-Module PSScriptAnalyzer -RequiredVersion $PSSA.Version -Scope CurrentUser -Repository PSGallery -SkipPublisherCheck -AllowClobber -Verbose
            }
        } finally {
            # Put Policy back so we don't needlessly change environments permanently
            Set-PSRepository PSGallery -InstallationPolicy $Policy
        }
      displayName: "Ensure pre-requisites"

    # Make a Pester test script for PSScriptAnalyzer
    - powershell: |
        $TestFile = New-Item $Env:TEMP/$([guid]::NewGuid())/PSScriptAnalyzer.Tests.ps1 -Type File -Force
        "##vso[task.setvariable variable=TestPath]$($TestFile.Fullname)"
        Set-Content $TestFile.Fullname '
        Import-Module PSScriptAnalyzer
        $ExcludeRules = @(${{ parameters.excludeRules }})
        $CustomRulePath = "${{ parameters.customRulePath }}"
        $Path = "${{ parameters.stagingDirectory }}"
        if ($Modules = @(${{ parameters.modulesToImport }})) {
          $Env:PSModulePath = $Path + ";" + $Env:PSModulePath
          Import-Module $Modules
        }
        Describe "PSScriptAnalyzer" {
          $Path | Should Exist
          $ScriptAnalyzerConfig = @{
            Path = $Path
            Recurse = $true
            IncludeDefaultRules = $true
            ExcludeRule = $ExcludeRules
          }
          $Rules = Get-ScriptAnalyzerRule | Where-Object RuleName -notin $ExcludeRules
          if ($CustomRulePath) {
            $CustomRulePath | Should Exist

            if ($CustomRules = Get-ScriptAnalyzerRule -CustomRulePath $CustomRulePath -RecurseCustomRulePath) {
              $Rules += $CustomRules
              $ScriptAnalyzerConfig += @{
                CustomRulePath = $CustomRulePath
                RecurseCustomRulePath = $true
              }
            }
          }
          $Analysis = Invoke-ScriptAnalyzer @ScriptAnalyzerConfig
          # Write a result for each rule
          foreach ($Rule in $Rules.RuleName) {
            It "$Rule" {
              if ($Failures = $Analysis.Where({$_.RuleName -EQ "$Rule"})) {
                throw (
                  [Management.Automation.ErrorRecord]::new(
                    ([Exception]::new(($Failures.ForEach{$_.ScriptName + ":" + $_.Line + " " + $_.Message} -join "`n"))),
                    "ScriptAnalyzerViolation",
                    "SyntaxError",
                    $Failures)
                )
              }
            }
          }
        }'
      displayName: 'Generate ScriptAnalyzer Test'

    - template: Pester-step.yml
      parameters:
        testsDirectory: $(TestPath)
        additionalModulePath: ${{ parameters.stagingDirectory }}
        resultsFile: '$(Common.TestResultsDirectory)/ScriptAnalyzer-$(Build.SourceVersion).xml'

    - task: PublishTestResults@2
      displayName: 'Publish Script Analyzer Results'
      inputs:
        testResultsFormat: NUnit
        testResultsFiles: '$(Common.TestResultsDirectory)/ScriptAnalyzer-$(Build.SourceVersion).xml'
        searchFolder: '$(Common.TestResultsDirectory)'
      condition: succeededOrFailed()

